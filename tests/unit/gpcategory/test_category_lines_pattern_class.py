"""
Unit tests for the `textfsmgen.gpcategory.CategoryLinePattern` class.

Usage
-----
Run pytest in the project root to execute these tests:
    $ pytest tests/unit/gpcategory/test_category_lines_pattern_class.py
    or
    $ python -m pytest tests/unit/gpcategory/test_category_lines_pattern_class.py
"""
import re
import pytest

from textfsmgen.core import get_textfsm_template
from textfsmgen.verify import verify

from textfsmgen.gpcategory import CategoryLinesPattern

from tests.unit import replace_dates_with_placeholder

from textfsmgen.deps import genericlib_normalize_return_output_text as normalize_return_output_text


class DataForStartingEndingArgumentsTests:
    """
    Test data provider for verifying `CategoryLinesPattern` behavior
    with `starting_from` and `ending_to` arguments.
    """
    @normalize_return_output_text
    def get_test_data(self):
        """
        Returns sample multiline input data containing categories such as
        fruits, meat, and drinks, along with surrounding lines.
        """
        test_data = """
            line 1: blab blab
            line 2: 123 blab
            fruits: orange, peach
            meat: pork
            drinks: water
            line k: 1.12 blab
            other fruits: mango
            other meat: chicken
            other drinks: pepsi
            """
        return test_data


    @normalize_return_output_text
    def get_expected_snippet(self):
        """
        Returns the expected template snippet generated from the test data,
        including parsing rules for digits, mixed phrases, and letters.
        """
        expected_snippet = r"""
            line 2: digits() blab -> Table
            Table
            fruits: mixed_phrase(var_fruits)
            meat: letters(var_meat)
            drinks: letters(var_drinks)
            line k: number() blab -> EOF            
        """
        return expected_snippet


    @normalize_return_output_text
    def get_expected_textfsm_template(self):
        """
        Returns the expected full TextFSM template with normalized date
        placeholder (``YYYY-mm-dd``)
        """
        textfsm_template = r"""
            ################################################################################
            # Template is generated by TextFSM Generator Community Edition
            # Created date: YYYY-mm-dd
            ################################################################################
            Value fruits ([\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*( [\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*)+)
            Value meat ([a-zA-Z]+)
            Value drinks ([a-zA-Z]+)
    
            Start
              ^line 2: \d+ blab -> Table
    
            Table
              ^fruits: ${fruits}
              ^meat: ${meat}
              ^drinks: ${drinks}
              ^line k: \d*[.]?\d+ blab -> EOF
        """
        return textfsm_template

    def get_expected_result(self):  # noqa
        return [{
            'fruits': 'orange, peach',
            'meat': 'pork',
            'drinks': 'water'
        }]


class DataForToRegexTests:
    @normalize_return_output_text
    def get_test_data(self):
        test_data = """
            fruits: orange, peach
            meat: pork
            drinks: water
            """
        return test_data

    @normalize_return_output_text
    def get_other_test_data(self):
        test_data = """
            blab blab 1 - +++ ***
            fruits: orange, peach
            blab blab 2 - (?P<)
            meat: pork
            drinks: water
            """
        return test_data

    @normalize_return_output_text
    def get_expected_pattern(self):
        fruits_pat = r"fruits: *(?P<fruits>[\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*( [\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*)+)(\r?\n|\r)"  # noqa
        meat_pat = r"meat: *(?P<meat>[a-zA-Z]+)(\r?\n|\r)"
        drink_pat = r"drinks: *(?P<drinks>[a-zA-Z]+)"
        expected_pattern = f"{fruits_pat}{meat_pat}{drink_pat}"
        return expected_pattern

    @normalize_return_output_text
    def get_other_expected_pattern(self):
        line1_pat = r'blab blab 1 - \+{2,} \*{2,}(\r?\n|\r)'
        fruits_pat = r"fruits: *(?P<fruits>[\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*( [\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*)+)(\r?\n|\r)"  # noqa
        line3_pat = r'blab blab 2 - \(\?P<\)(\r?\n|\r)'
        meat_pat = r"meat: *(?P<meat>[a-zA-Z]+)(\r?\n|\r)"
        drink_pat = r"drinks: *(?P<drinks>[a-zA-Z]+)"
        expected_pattern = f"{line1_pat}{fruits_pat}{line3_pat}{meat_pat}{drink_pat}"
        return expected_pattern

    def get_expected_result(self):  # noqa
        return {'fruits': 'orange, peach', 'meat': 'pork', 'drinks': 'water'}

    def get_other_expected_result(self):
        return self.get_expected_result()


class DataForToTemplateSnippetTests:
    reference_data = DataForToRegexTests()

    @normalize_return_output_text
    def get_test_data(self):
        return self.reference_data.get_test_data()

    @normalize_return_output_text
    def get_other_test_data(self):
        return self.reference_data.get_other_test_data()

    @normalize_return_output_text
    def get_expected_snippet(self):
        expected_snippet = """
            fruits: mixed_phrase(var_fruits)
            meat: letters(var_meat)
            drinks: letters(var_drinks)
        """
        return expected_snippet

    @normalize_return_output_text
    def get_other_expected_snippet(self):
        other_expected_snippet = """
            blab blab 1 - +++ ***
            fruits: mixed_phrase(var_fruits)
            blab blab 2 - (?P<)
            meat: letters(var_meat)
            drinks: letters(var_drinks)
        """
        return other_expected_snippet

    @normalize_return_output_text
    def get_expected_textfsm_template(self):
        expected_textfsm_template = r"""
            ################################################################################
            # Template is generated by TextFSM Generator Community Edition
            # Created date: YYYY-mm-dd
            ################################################################################
            Value fruits ([\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*( [\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*)+)
            Value meat ([a-zA-Z]+)
            Value drinks ([a-zA-Z]+)

            Start
              ^fruits: ${fruits}
              ^meat: ${meat}
              ^drinks: ${drinks}
        """
        return expected_textfsm_template

    @normalize_return_output_text
    def get_other_expected_textfsm_template(self):
        other_expected_textfsm_template = r"""
             ################################################################################
            # Template is generated by TextFSM Generator Community Edition
            # Created date: YYYY-mm-dd
            ################################################################################
            Value fruits ([\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*( [\x21-\x7e]*[a-zA-Z0-9][\x21-\x7e]*)+)
            Value meat ([a-zA-Z]+)
            Value drinks ([a-zA-Z]+)

            Start
              ^blab blab 1 - \+{2,} \*{2,}
              ^fruits: ${fruits}
              ^blab blab 2 - \(\?P<\)
              ^meat: ${meat}
              ^drinks: ${drinks}
        """
        return other_expected_textfsm_template

    def get_expected_result(self):
        return [self.reference_data.get_expected_result()]

    def get_other_expected_result(self):
        return self.get_expected_result()


class TestCategoryLinesPattern:
    """Test class for CategoryLinesPattern"""

    testcase_for_starting_ending_args = DataForStartingEndingArgumentsTests()
    testcase_for_to_regex = DataForToRegexTests()
    testcase_for_to_template_snippet = DataForToTemplateSnippetTests()

    @pytest.mark.parametrize(
        "test_data, expected_snippet, expected_textfsm_template, expected_result",
        [
            (
                testcase_for_starting_ending_args.get_test_data(),
                testcase_for_starting_ending_args.get_expected_snippet(),
                testcase_for_starting_ending_args.get_expected_textfsm_template(),
                testcase_for_starting_ending_args.get_expected_result(),
            ),
        ]
    )
    def test_to_starting_from_and_ending_to_arguments(
            self, test_data, expected_snippet,
            expected_textfsm_template, expected_result
    ):
        # --- Action ---

        node = CategoryLinesPattern(test_data, starting_from=1, ending_to=5)
        generated_snippet = node.to_template_snippet()

        # --- Assertions ---
        # Snippet matches expected

        assert generated_snippet == expected_snippet

        # TextFSM template matches expected (normalize dates first)

        # Generate TextFSM template from snippet
        raw_textfsm_template = get_textfsm_template(generated_snippet)

        # Normalize template by replacing actual dates with placeholder
        normalized_textfsm_template = replace_dates_with_placeholder(
            raw_textfsm_template)

        # Compare against expected template
        assert normalized_textfsm_template == expected_textfsm_template

        # Verification passes

        is_verified = verify(generated_snippet, test_data, expected_result=expected_result)
        assert is_verified

    @pytest.mark.parametrize(
        "test_data,expected_pattern,expected_result",
        [
            (
                testcase_for_to_regex.get_test_data(),
                testcase_for_to_regex.get_expected_pattern(),
                testcase_for_to_regex.get_expected_result()
            ),
            (
                testcase_for_to_regex.get_test_data(),
                testcase_for_to_regex.get_expected_pattern(),
                testcase_for_to_regex.get_expected_result()
            ),
        ]
    )
    def test_to_regex(self, test_data,expected_pattern,expected_result) -> None:
        # --- Action ---
        node = CategoryLinesPattern(test_data)
        pattern = node.to_regex()

        # --- Assertions ---
        assert pattern == expected_pattern, (
            f"Generated pattern {pattern!r} does not match expected {expected_pattern!r}"
        )

        match = re.match(pattern, test_data)
        if match:
            result = match.groupdict()
            assert result == expected_result, (
                f"Regex groups {result} do not match expected {expected_result}"
            )
        else:
            pytest.fail(f"No match found. Expected pattern: {pattern!r}")

    @pytest.mark.parametrize(
        "test_data, expected_snippet, expected_textfsm_template, expected_result",
        [
            (
                testcase_for_to_template_snippet.get_test_data(),
                testcase_for_to_template_snippet.get_expected_snippet(),
                testcase_for_to_template_snippet.get_expected_textfsm_template(),
                testcase_for_to_template_snippet.get_expected_result(),
            ),
            (
                testcase_for_to_template_snippet.get_other_test_data(),
                testcase_for_to_template_snippet.get_other_expected_snippet(),
                testcase_for_to_template_snippet.get_other_expected_textfsm_template(),
                testcase_for_to_template_snippet.get_other_expected_result(),
            ),
        ]
    )
    def test_to_template_snippet(
            self, test_data, expected_snippet,
            expected_textfsm_template, expected_result
    ) -> None:
        # --- Action ---
        node = CategoryLinesPattern(test_data)
        tmpl_snippet = node.to_template_snippet()

        # --- Assertions ---
        # Snippet matches expected
        assert tmpl_snippet == expected_snippet, (
            f"Generated snippet {tmpl_snippet!r} does not match expected {expected_snippet!r}"
        )

        # Generate TextFSM template from snippet
        raw_textfsm_template = get_textfsm_template(tmpl_snippet)

        # Normalize template by replacing actual dates with placeholder
        normalized_textfsm_template = replace_dates_with_placeholder(
            raw_textfsm_template)

        # Template matches expected
        assert normalized_textfsm_template == expected_textfsm_template, (
            "Normalized TextFSM template does not match expected template"
        )

        # Verification passes
        is_verified = verify(tmpl_snippet, test_data,
                             expected_result=expected_result)
        assert is_verified, "Verification failed: parsed result did not match expected"